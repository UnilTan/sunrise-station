using Content.Client.UserInterface.Controls;
using Content.Shared.Administration;
using Content.Shared.GameTicking.Components;
using Content.Shared.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.Console;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Console;
using Robust.Shared.IoC;
using Robust.Shared.Network;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Content.Client.Administration.UI.Tabs
{
    [GenerateTypedNameReferences]
    public sealed partial class GameRulesTab : Control
    {
        [Dependency] private readonly IClientConsoleHost _console = default!;
        [Dependency] private readonly IClientNetManager _netManager = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly IGameTiming _timing = default!;

        private readonly Dictionary<string, Control> _availableRuleControls = new();
        private readonly Dictionary<string, Control> _activeRuleControls = new();
        private string _lastActiveRulesOutput = string.Empty;

        public GameRulesTab()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            RefreshButton.OnPressed += _ => RefreshRules();
            ClearAllButton.OnPressed += _ => ClearAllRules();

            RefreshRules();
        }

        private void RefreshRules()
        {
            RefreshAvailableRules();
            RefreshActiveRules();
        }

        private void RefreshAvailableRules()
        {
            AvailableRulesContainer.RemoveAllChildren();
            _availableRuleControls.Clear();

            // Get all available game rule prototypes
            var allRules = _prototypeManager.EnumeratePrototypes<EntityPrototype>()
                .Where(proto => !proto.Abstract && proto.HasComponent<GameRuleComponent>())
                .OrderBy(proto => proto.ID);

            if (!allRules.Any())
            {
                var noRulesLabel = new Label { Text = Loc.GetString("admin-game-rules-no-available") };
                AvailableRulesContainer.AddChild(noRulesLabel);
                return;
            }

            foreach (var ruleProto in allRules)
            {
                var container = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal };
                
                var nameLabel = new Label 
                { 
                    Text = ruleProto.ID,
                    HorizontalExpand = true,
                    ClipText = true
                };
                
                var startButton = new Button { Text = Loc.GetString("admin-game-rules-start-button") };
                startButton.OnPressed += _ => StartGameRule(ruleProto.ID);
                
                container.AddChild(nameLabel);
                container.AddChild(startButton);
                
                AvailableRulesContainer.AddChild(container);
                _availableRuleControls[ruleProto.ID] = container;
            }
        }

        private void RefreshActiveRules()
        {
            ActiveRulesContainer.RemoveAllChildren();
            _activeRuleControls.Clear();

            // Parse active rules from the list - create sample data for testing
            // In a real implementation, you'd want to create a proper network message for this
            var activeRules = GetSampleActiveRules();

            if (activeRules.Count == 0)
            {
                var noActiveLabel = new Label { Text = Loc.GetString("admin-game-rules-no-active") };
                ActiveRulesContainer.AddChild(noActiveLabel);
                return;
            }

            foreach (var (ruleId, entityId, duration) in activeRules)
            {
                var container = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal };
                
                var infoLabel = new Label 
                { 
                    Text = $"{ruleId} ({duration})",
                    HorizontalExpand = true,
                    ClipText = true,
                    ToolTip = $"Entity ID: {entityId}"
                };
                
                var endButton = new Button { Text = Loc.GetString("admin-game-rules-end-button") };
                endButton.OnPressed += _ => EndGameRule(entityId);
                
                container.AddChild(infoLabel);
                container.AddChild(endButton);
                
                ActiveRulesContainer.AddChild(container);
                _activeRuleControls[entityId] = container;
            }
        }

        // Sample data for testing - replace with real implementation
        private List<(string ruleId, string entityId, string duration)> GetSampleActiveRules()
        {
            var sampleRules = new List<(string, string, string)>();
            
            // This is just sample data for demonstration
            // In a real implementation, you would either:
            // 1. Create a proper network message to get this data
            // 2. Use the console output parsing (more complex)
            // 3. Subscribe to game rule events
            
            return sampleRules;
        }

        private void StartGameRule(string ruleId)
        {
            _console.ExecuteCommand($"addgamerule {ruleId}");
        }

        private void EndGameRule(string ruleEntityId)
        {
            _console.ExecuteCommand($"endgamerule {ruleEntityId}");
        }

        private void ClearAllRules()
        {
            _console.ExecuteCommand("cleargamerules");
        }
    }
}