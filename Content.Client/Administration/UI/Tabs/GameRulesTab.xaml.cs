using Content.Client.UserInterface.Controls;
using Content.Shared.Administration;
using Content.Shared.GameTicking.Components;
using Content.Shared.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.Console;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Console;
using Robust.Shared.IoC;
using Robust.Shared.Network;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using System.Collections.Generic;
using System.Linq;

namespace Content.Client.Administration.UI.Tabs
{
    [GenerateTypedNameReferences]
    public sealed partial class GameRulesTab : Control
    {
        [Dependency] private readonly IClientConsoleHost _console = default!;
        [Dependency] private readonly IClientNetManager _netManager = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly IGameTiming _timing = default!;

        private readonly Dictionary<string, Control> _availableRuleControls = new();
        private readonly Dictionary<string, Control> _activeRuleControls = new();

        public GameRulesTab()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            RefreshButton.OnPressed += _ => RefreshRules();
            ClearAllButton.OnPressed += _ => ClearAllRules();

            RefreshRules();
        }

        private void RefreshRules()
        {
            RefreshAvailableRules();
            RefreshActiveRules();
        }

        private void RefreshAvailableRules()
        {
            AvailableRulesContainer.RemoveAllChildren();
            _availableRuleControls.Clear();

            // Get all available game rule prototypes
            var allRules = _prototypeManager.EnumeratePrototypes<EntityPrototype>()
                .Where(proto => !proto.Abstract && proto.HasComponent<GameRuleComponent>())
                .OrderBy(proto => proto.ID);

            if (!allRules.Any())
            {
                var noRulesLabel = new Label { Text = Loc.GetString("admin-game-rules-no-available") };
                AvailableRulesContainer.AddChild(noRulesLabel);
                return;
            }

            foreach (var ruleProto in allRules)
            {
                var container = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal };
                
                var nameLabel = new Label 
                { 
                    Text = ruleProto.ID,
                    HorizontalExpand = true,
                    ClipText = true
                };
                
                var startButton = new Button { Text = Loc.GetString("admin-game-rules-start-button") };
                startButton.OnPressed += _ => StartGameRule(ruleProto.ID);
                
                container.AddChild(nameLabel);
                container.AddChild(startButton);
                
                AvailableRulesContainer.AddChild(container);
                _availableRuleControls[ruleProto.ID] = container;
            }
        }

        private void RefreshActiveRules()
        {
            ActiveRulesContainer.RemoveAllChildren();
            _activeRuleControls.Clear();

            // Request active rules from server via console command
            // This is a simple approach - in a real implementation you might want a proper network message
            _console.ExecuteCommand("listgamerules");

            // For now, show a placeholder as we can't easily get the list synchronously
            var placeholderLabel = new Label { Text = Loc.GetString("admin-game-rules-no-active") };
            ActiveRulesContainer.AddChild(placeholderLabel);
        }

        private void StartGameRule(string ruleId)
        {
            _console.ExecuteCommand($"addgamerule {ruleId}");
        }

        private void EndGameRule(string ruleEntityId)
        {
            _console.ExecuteCommand($"endgamerule {ruleEntityId}");
        }

        private void ClearAllRules()
        {
            _console.ExecuteCommand("cleargamerules");
        }
    }
}