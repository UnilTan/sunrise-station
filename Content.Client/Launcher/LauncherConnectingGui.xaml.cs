using System.Linq;
using Content.Client._Sunrise.ServersHub;
using Content.Client.Parallax;
using Content.Client.Stylesheets;
using Content.Server.GameTicking.Prototypes;
using Content.Shared._Sunrise.Lobby;
using Content.Shared._Sunrise.ServersHub;
using Content.Shared._Sunrise.SunriseCCVars;
using Content.Shared.CCVar;
using Content.Shared.Dataset;
using Content.Shared.GameTicking;
using Robust.Client.AutoGenerated;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.IoC;
using Robust.Shared.Log;
using Robust.Shared.Timing;
using Robust.Shared.Network;
using Robust.Shared.Prototypes;
using Robust.Shared.Random;
using Robust.Shared.Utility;

namespace Content.Client.Launcher
{
    [GenerateTypedNameReferences]
    public sealed partial class LauncherConnectingGui : Control
    {
        [Dependency] private readonly IUriOpener _uri = default!; // Sunrise-Edit

        private const float RedialWaitTimeSeconds = 10f; // Sunrise-edit
        private readonly LauncherConnecting _state;
        private float _waitTime;

        // Pressing reconnect will redial instead of simply reconnecting.
        private bool _redial;

        private readonly IRobustRandom _random;
        private readonly IPrototypeManager _prototype;
        private readonly IConfigurationManager _cfg;
        private readonly IClipboardManager _clipboard;
        private readonly ServersHubManager _serversHubManager; // Sunrise-Edit
        private readonly IResourceCache _resourceCache;
        
        private static readonly Robust.Shared.Log.ISawmill Logger = Robust.Shared.Log.Logger.GetSawmill("launcher.connecting");

        private string _discordLink = ""; // Sunrise-Edit
        private string _telegramLink = ""; // Sunrise-Edit

        public LauncherConnectingGui(LauncherConnecting state, IRobustRandom random,
            IPrototypeManager prototype, IConfigurationManager config, IClipboardManager clipboard,
            ServersHubManager serversHubManager, IResourceCache resourceCache) // Sunrise-Edit
        {
            _state = state;
            _random = random;
            _prototype = prototype;
            _cfg = config;
            _clipboard = clipboard;
            _serversHubManager = serversHubManager; // Sunrise-Edit
            _resourceCache = resourceCache;

            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            LayoutContainer.SetAnchorPreset(this, LayoutContainer.LayoutPreset.Wide);

            Stylesheet = IoCManager.Resolve<IStylesheetManager>().SheetSpace;

            ChangeLoginTip();
            RetryButton.OnPressed += ReconnectButtonPressed;
            ReconnectButton.OnPressed += ReconnectButtonPressed;

            CopyButton.OnPressed += CopyButtonPressed;
            CopyButtonDisconnected.OnPressed += CopyButtonDisconnectedPressed;
            ExitButton.OnPressed += _ => _state.Exit();

            _cfg.OnValueChanged(SunriseCCVars.BanDiscordLink, s => _discordLink = s, true); // Sunrise-Edit
            _cfg.OnValueChanged(SunriseCCVars.BanTelegramLink, s => _telegramLink = s, true); // Sunrise-Edit

            Discord.OnPressed += _ => _uri.OpenUri(_discordLink); // Sunrise-Edit
            Telegram.OnPressed += _ => _uri.OpenUri(_telegramLink); // Sunrise-Edit

            var addr = state.Address;
            if (addr != null)
                ConnectingAddress.Text = addr;

            state.PageChanged += OnPageChanged;
            state.ConnectFailReasonChanged += ConnectFailReasonChanged;
            state.ConnectionStateChanged += ConnectionStateChanged;
            state.ConnectFailed += HandleDisconnectReason;

            ConnectionStateChanged(state.ConnectionState);

            // Redial flag setup
            var edim = IoCManager.Resolve<ExtendedDisconnectInformationManager>();
            edim.LastNetDisconnectedArgsChanged += LastNetDisconnectedArgsChanged;
            LastNetDisconnectedArgsChanged(edim.LastNetDisconnectedArgs);

            _serversHubManager.ServersDataListChanged += RefreshServersHubHeader; // Sunrise-Edit
            
            // Apply user background preferences to loading screen
            ApplyUserBackgroundPreferences();
        }

        // Sunrise-Start
        private void RefreshServersHubHeader(List<ServerHubEntry> servers)
        {
            var totalPlayers = servers.Sum(server => server.CurrentPlayers);
            var maxPlayers = servers.Sum(server => server.MaxPlayers);
            ServersHubHeaderLabel.Text = Loc.GetString("serverhub-playingnow", ("total", totalPlayers), ("max", maxPlayers)); // Sunrise-Edit
        }
        // Sunrise-End

        // Just button, there's only one at once anyways :)
        private void ReconnectButtonPressed(BaseButton.ButtonEventArgs args)
        {
            if (_redial)
            {
                // Redial shouldn't fail, but if it does, try a reconnect (maybe we're being run from debug)
                if (_state.Redial())
                    return;
            }

            _state.RetryConnect();
        }

        private void CopyButtonPressed(BaseButton.ButtonEventArgs args)
        {
            CopyText(ConnectFailReason.Text);
        }

        private void CopyButtonDisconnectedPressed(BaseButton.ButtonEventArgs args)
        {
            CopyText(DisconnectReason.Text);
        }

        private void CopyText(string? text)
        {
            if (!string.IsNullOrEmpty(text))
            {
                _clipboard.SetText(text);
            }
        }

        private void ConnectFailReasonChanged(string? reason)
        {
            ConnectFailReason.SetMessage(reason == null
                ? ""
                : Loc.GetString("connecting-fail-reason", ("reason", reason)));
        }

        private void LastNetDisconnectedArgsChanged(NetDisconnectedArgs? args)
        {
            HandleDisconnectReason(args);
        }

        private void HandleDisconnectReason(INetStructuredReason? reason)
        {
            if (reason == null)
            {
                _waitTime = 0;
                _redial = false;
            }
            else
            {
                _redial = reason.RedialFlag;

                if (reason.Message.Int32Of("delay") is { } delay)
                {
                    _waitTime = delay;
                }
                else if (_redial)
                {
                    _waitTime = RedialWaitTimeSeconds;
                }

            }
        }

        private void ChangeLoginTip()
        {
            var tipsDataset = _cfg.GetCVar(CCVars.LoginTipsDataset);
            var loginTipsEnabled = _prototype.TryIndex<LocalizedDatasetPrototype>(tipsDataset, out var tips);

            LoginTips.Visible = loginTipsEnabled;
            if (!loginTipsEnabled)
            {
                return;
            }

            var tipList = tips!.Values;

            if (tipList.Count == 0)
                return;

            var randomIndex = _random.Next(tipList.Count);
            var tip = tipList[randomIndex];
            LoginTip.SetMessage(Loc.GetString(tip));

            LoginTipTitle.Text = Loc.GetString("connecting-window-tip", ("numberTip", randomIndex));
        }

        protected override void FrameUpdate(FrameEventArgs args)
        {
            base.FrameUpdate(args);

            var button = _state.CurrentPage == LauncherConnecting.Page.ConnectFailed
                ? RetryButton
                : ReconnectButton;

            _waitTime -= args.DeltaSeconds;
            if (_waitTime <= 0)
            {
                button.Disabled = false;
                var key = _redial
                    ? "connecting-redial"
                    : _state.CurrentPage == LauncherConnecting.Page.ConnectFailed
                        ? "connecting-reconnect"
                        : "connecting-retry";

                button.Text = Loc.GetString(key);
            }
            else
            {
                button.Disabled = true;
                button.Text = Loc.GetString("connecting-redial-wait", ("time", _waitTime.ToString("00.000")));
            }
        }

        private void OnPageChanged(LauncherConnecting.Page page)
        {
            ConnectingStatus.Visible = page == LauncherConnecting.Page.Connecting;
            ConnectFail.Visible = page == LauncherConnecting.Page.ConnectFailed;
            Disconnected.Visible = page == LauncherConnecting.Page.Disconnected;

            if (page == LauncherConnecting.Page.Disconnected)
            {
                DisconnectReason.Text = _state.LastDisconnectReason;
                ServersHub.Visible = true; // Sunrise-edit
            }
        }

        private void ConnectionStateChanged(ClientConnectionState state)
        {
            ConnectStatus.Text = Loc.GetString($"connecting-state-{state}");
        }

        /// <summary>
        /// Apply user background preferences to the loading screen based on user settings.
        /// This ensures the loading screen respects user preferences for background type, parallax, art, and animations.
        /// </summary>
        private void ApplyUserBackgroundPreferences()
        {
            var userBackgroundType = _cfg.GetCVar(SunriseCCVars.LobbyBackgroundType);
            
            // Apply user-chosen background type, or use parallax as default if "Random"
            if (userBackgroundType == "Random")
            {
                SetLoadingBackgroundType("Parallax"); // Default to parallax for loading screen
            }
            else
            {
                SetLoadingBackgroundType(userBackgroundType);
            }
            
            // Apply specific preferences based on background type
            ApplySpecificBackgroundPreferences();
        }
        
        /// <summary>
        /// Set the background type for the loading screen (Parallax, Art, or Animation).
        /// </summary>
        private void SetLoadingBackgroundType(string backgroundType)
        {
            if (!Enum.TryParse(backgroundType, out LobbyBackgroundType backgroundTypeEnum))
            {
                backgroundTypeEnum = LobbyBackgroundType.Parallax; // Default fallback
            }
            
            // Show/hide appropriate background elements
            switch (backgroundTypeEnum)
            {
                case LobbyBackgroundType.Parallax:
                    LoadingAnimation.Visible = false;
                    LoadingArt.Visible = false;
                    LoadingParallax.Visible = true;
                    break;
                case LobbyBackgroundType.Art:
                    LoadingAnimation.Visible = false;
                    LoadingArt.Visible = true;
                    LoadingParallax.Visible = false;
                    break;
                case LobbyBackgroundType.Animation:
                    LoadingAnimation.Visible = true;
                    LoadingArt.Visible = false;
                    LoadingParallax.Visible = false;
                    break;
            }
        }
        
        /// <summary>
        /// Apply specific user preferences for parallax, art, and animation.
        /// </summary>
        private void ApplySpecificBackgroundPreferences()
        {
            // Apply parallax preference if not "Random"
            var userParallax = _cfg.GetCVar(SunriseCCVars.LobbyParallax);
            if (userParallax != "Random")
            {
                if (_prototype.TryIndex<LobbyParallaxPrototype>(userParallax, out var parallaxPrototype))
                {
                    LoadingParallax.ParallaxPrototype = parallaxPrototype.Parallax;
                    Logger.Debug($"Applied user parallax '{parallaxPrototype.Parallax}' to loading screen");
                }
                else
                {
                    Logger.Warning($"Failed to find LobbyParallaxPrototype with ID: {userParallax} for loading screen");
                }
            }
            
            // Apply art preference if not "Random"
            var userArt = _cfg.GetCVar(SunriseCCVars.LobbyArt);
            if (userArt != "Random")
            {
                if (_prototype.TryIndex<LobbyBackgroundPrototype>(userArt, out var artPrototype))
                {
                    LoadingArt.Texture = _resourceCache.GetResource<TextureResource>(artPrototype.Background);
                    Logger.Debug($"Applied user art '{artPrototype.Background}' to loading screen");
                }
                else
                {
                    Logger.Warning($"Failed to find LobbyBackgroundPrototype with ID: {userArt} for loading screen");
                }
            }
            
            // Apply animation preference if not "Random"
            var userAnimation = _cfg.GetCVar(SunriseCCVars.LobbyAnimation);
            if (userAnimation != "Random")
            {
                if (_prototype.TryIndex<LobbyAnimationPrototype>(userAnimation, out var animationPrototype))
                {
                    LoadingAnimation.SetFromSpriteSpecifier(new SpriteSpecifier.Rsi(new ResPath(animationPrototype.RawPath), animationPrototype.State));
                    LoadingAnimation.DisplayRect.TextureScale = animationPrototype.Scale;
                    LoadingAnimation.DisplayRect.Stretch = TextureRect.StretchMode.KeepAspectCovered;
                    LoadingAnimation.DisplayRect.HorizontalExpand = true;
                    LoadingAnimation.DisplayRect.VerticalExpand = true;
                    Logger.Debug($"Applied user animation '{animationPrototype.RawPath}:{animationPrototype.State}' to loading screen");
                }
                else
                {
                    Logger.Warning($"Failed to find LobbyAnimationPrototype with ID: {userAnimation} for loading screen");
                }
            }
        }
    }
}
